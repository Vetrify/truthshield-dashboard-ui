// Code generated by wunderctl. DO NOT EDIT.

import {
	FakeAdminPortalResponse,
	FakeWeatherResponse,
	PastLaunchesResponse,
	ProtectedWeatherResponse,
	ProtectedWeatherInput,
	InternalProtectedWeatherInput,
	InjectedProtectedWeatherInput,
	WeatherResponse,
	WeatherInput,
	InternalWeatherInput,
	InjectedWeatherInput,
} from "./models";
import type { WunderGraphRequestContext, Context, WunderGraphRequest, WunderGraphResponse } from "@wundergraph/sdk";
import type { InternalClient } from "./wundergraph.internal.client";
import type { User } from "./wundergraph.server";

export type AuthenticationResponse = AuthenticationOK | AuthenticationDeny;

export interface AuthenticationOK {
	status: "ok";
	user: User;
}

export interface AuthenticationDeny {
	status: "deny";
	message: string;
}

// use SKIP to skip the hook and continue the request / response chain without modifying the request / response
export type SKIP = "skip";

// use CANCEL to skip the hook and cancel the request / response chain
// this is semantically equal to throwing an error (500)
export type CANCEL = "cancel";

export type WUNDERGRAPH_OPERATION = "FakeAdminPortal" | "FakeWeather" | "PastLaunches" | "ProtectedWeather" | "Weather";

export interface GlobalHooksConfig {
	httpTransport?: {
		// onRequest is called right before the request is sent
		// it can be used to modify the request
		// you can return SKIP to skip the hook and continue the request chain without modifying the request
		// you can return CANCEL to cancel the request chain and return a 500 error
		// not returning anything or undefined has the same effect as returning SKIP
		onRequest?: {
			hook: (
				ctx: WunderGraphRequestContext<User>,
				request: WunderGraphRequest
			) => Promise<WunderGraphRequest | SKIP | CANCEL | void>;
			// calling the httpTransport hooks has a case, because the custom httpTransport hooks have to be called for each request
			// for this reason, you have to explicitly enable the hook for each Operation
			enableForOperations?: WUNDERGRAPH_OPERATION[];
			// enableForAllOperations will disregard the enableForOperations property and enable the hook for all operations
			enableForAllOperations?: boolean;
		};
		// onResponse is called right after the response is received
		// it can be used to modify the response
		// you can return SKIP to skip the hook and continue the response chain without modifying the response
		// you can return CANCEL to cancel the response chain and return a 500 error
		// not returning anything or undefined has the same effect as returning SKIP
		onResponse?: {
			hook: (
				ctx: WunderGraphRequestContext<User>,
				response: WunderGraphResponse
			) => Promise<WunderGraphResponse | SKIP | CANCEL | void>;
			// calling the httpTransport hooks has a case, because the custom httpTransport hooks have to be called for each request
			// for this reason, you have to explicitly enable the hook for each Operation
			enableForOperations?: WUNDERGRAPH_OPERATION[];
			// enableForAllOperations will disregard the enableForOperations property and enable the hook for all operations
			enableForAllOperations?: boolean;
		};
	};
}

export type JSONValue = string | number | boolean | JSONObject | Array<JSONValue>;

export type JSONObject = { [key: string]: JSONValue };

export interface HooksConfig {
	global?: GlobalHooksConfig;
	authentication?: {
		postAuthentication?: (user: User) => Promise<void>;
		mutatingPostAuthentication?: (user: User) => Promise<AuthenticationResponse>;
		revalidate?: (user: User) => Promise<AuthenticationResponse>;
	};
	queries?: {
		FakeAdminPortal?: {
			mockResolve?: (ctx: Context<User, InternalClient>) => Promise<FakeAdminPortalResponse>;
			preResolve?: (ctx: Context<User, InternalClient>) => Promise<void>;
			postResolve?: (ctx: Context<User, InternalClient>, response: FakeAdminPortalResponse) => Promise<void>;
			customResolve?: (ctx: Context<User, InternalClient>) => Promise<void | FakeAdminPortalResponse>;
			mutatingPostResolve?: (
				ctx: Context<User, InternalClient>,
				response: FakeAdminPortalResponse
			) => Promise<FakeAdminPortalResponse>;
		};
		FakeWeather?: {
			mockResolve?: (ctx: Context<User, InternalClient>) => Promise<FakeWeatherResponse>;
			preResolve?: (ctx: Context<User, InternalClient>) => Promise<void>;
			postResolve?: (ctx: Context<User, InternalClient>, response: FakeWeatherResponse) => Promise<void>;
			customResolve?: (ctx: Context<User, InternalClient>) => Promise<void | FakeWeatherResponse>;
			mutatingPostResolve?: (
				ctx: Context<User, InternalClient>,
				response: FakeWeatherResponse
			) => Promise<FakeWeatherResponse>;
		};
		PastLaunches?: {
			mockResolve?: (ctx: Context<User, InternalClient>) => Promise<PastLaunchesResponse>;
			preResolve?: (ctx: Context<User, InternalClient>) => Promise<void>;
			postResolve?: (ctx: Context<User, InternalClient>, response: PastLaunchesResponse) => Promise<void>;
			customResolve?: (ctx: Context<User, InternalClient>) => Promise<void | PastLaunchesResponse>;
			mutatingPostResolve?: (
				ctx: Context<User, InternalClient>,
				response: PastLaunchesResponse
			) => Promise<PastLaunchesResponse>;
		};
		ProtectedWeather?: {
			mockResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedProtectedWeatherInput
			) => Promise<ProtectedWeatherResponse>;
			preResolve?: (ctx: Context<User, InternalClient>, input: InjectedProtectedWeatherInput) => Promise<void>;
			mutatingPreResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedProtectedWeatherInput
			) => Promise<InjectedProtectedWeatherInput>;
			postResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedProtectedWeatherInput,
				response: ProtectedWeatherResponse
			) => Promise<void>;
			customResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedProtectedWeatherInput
			) => Promise<void | ProtectedWeatherResponse>;
			mutatingPostResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedProtectedWeatherInput,
				response: ProtectedWeatherResponse
			) => Promise<ProtectedWeatherResponse>;
		};
		Weather?: {
			mockResolve?: (ctx: Context<User, InternalClient>, input: InjectedWeatherInput) => Promise<WeatherResponse>;
			preResolve?: (ctx: Context<User, InternalClient>, input: InjectedWeatherInput) => Promise<void>;
			mutatingPreResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedWeatherInput
			) => Promise<InjectedWeatherInput>;
			postResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedWeatherInput,
				response: WeatherResponse
			) => Promise<void>;
			customResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedWeatherInput
			) => Promise<void | WeatherResponse>;
			mutatingPostResolve?: (
				ctx: Context<User, InternalClient>,
				input: InjectedWeatherInput,
				response: WeatherResponse
			) => Promise<WeatherResponse>;
		};
	};
	mutations?: {};
}
